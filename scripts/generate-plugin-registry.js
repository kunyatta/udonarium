const fs = require('fs');
const path = require('path');

const PLUGINS_DIR = path.join(__dirname, '../src/app/plugins');
const OUTPUT_DEV = path.join(PLUGINS_DIR, 'plugin-registry.ts');
const OUTPUT_PROD = path.join(PLUGINS_DIR, 'plugin-registry.prod.ts');

const IGNORE_DIRS = ['trashbox', 'backup', 'old', 'archive', 'node_modules', 'service', 'components', 'plugin-launcher'];
// plugin-launcher は手動で追加するか、あるいはmanifestがあっても特別扱いする必要があるか検討。
// 今回は「自動登録」の対象に含める方針で実装するが、module側の依存解決順序に注意。

console.log('Scanning plugins in:', PLUGINS_DIR);

function main() {
  const allPlugins = [];
  const prodPlugins = [];

  const items = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true });

  for (const item of items) {
    if (!item.isDirectory()) continue;
    const dirName = item.name;

    // 物理フィルタ
    if (dirName.startsWith('_') || dirName.startsWith('.')) continue;
    if (IGNORE_DIRS.includes(dirName)) continue;

    const manifestPath = path.join(PLUGINS_DIR, dirName, 'manifest.ts');
    if (!fs.existsSync(manifestPath)) {
      // manifestがない場合はスキップ（従来通り）
      continue;
    }

    // マニフェスト解析
    const manifestContent = fs.readFileSync(manifestPath, 'utf8');
    const isEnabled = extractFlag(manifestContent, 'isEnabled', true);
    const isExperimental = extractFlag(manifestContent, 'isExperimental', false);

    if (!isEnabled) {
      console.log(`[SKIP] ${dirName} (isEnabled: false)`);
      continue;
    }

    // エントリーポイント(*.plugin.ts)の特定
    const pluginFile = findPluginFile(path.join(PLUGINS_DIR, dirName));
    if (!pluginFile) {
      console.warn(`[WARN] ${dirName}: manifest.ts exists but *.plugin.ts not found.`);
      continue;
    }

    // モジュール名とクラス名を特定（簡易的な推測）
    // AngularのModuleではなく、Pluginクラスそのものを配列に入れる構造になっているため、
    // クラス名を特定する必要があるが、現状のplugins.module.tsはModuleをimportしている。
    // あれ？ environment.ts を見ると "CombatFlowModule" を import している。
    // ということは、自動登録すべきは "*.module.ts" なのか？
    // 確認が必要。
    
    // --> 現状の environment.ts は "Module" を配列に入れている。
    // なので、各プラグインディレクトリから "*.module.ts" を探すべき。
    
    const moduleInfo = findModuleInfo(path.join(PLUGINS_DIR, dirName));
    if (!moduleInfo) {
      // Moduleがない場合（例: SettingsPluginのようなUIなしプラグイン）はどうしている？
      // SettingsModuleがある。
      // つまり、全てのプラグインはModuleを持っている前提？
      console.warn(`[WARN] ${dirName}: Module file (*.module.ts) not found.`);
      continue;
    }

    const pluginEntry = {
      dirName: dirName,
      fileName: moduleInfo.fileName, // extensionなし
      className: moduleInfo.className
    };

    allPlugins.push(pluginEntry);
    if (!isExperimental) {
      prodPlugins.push(pluginEntry);
    } else {
      console.log(`[DEV ONLY] ${dirName} (isExperimental: true)`);
    }
  }

  // ファイル生成
  generateRegistryFile(OUTPUT_DEV, allPlugins, false);
  generateRegistryFile(OUTPUT_PROD, prodPlugins, true);
}

function extractFlag(content, key, defaultValue) {
  // 簡易解析: コメントアウトなどは考慮せず、単純に "key: value" の存在を確認する
  // 空白（改行含む）をすべて除去して正規化
  const minified = content.replace(/\s/g, '');
  
  if (minified.includes(`${key}:true`)) {
    return true;
  }
  if (minified.includes(`${key}:false`)) {
    return false;
  }
  return defaultValue;
}

function findModuleInfo(dirPath) {
  const files = fs.readdirSync(dirPath);
  const moduleFile = files.find(f => f.endsWith('.module.ts'));
  
  if (moduleFile) {
    const content = fs.readFileSync(path.join(dirPath, moduleFile), 'utf8');
    // export class XxxModule
    const match = content.match(/export\s+class\s+(\w+)/);
    if (match) {
      return {
        fileName: moduleFile.replace('.ts', ''),
        className: match[1]
      };
    }
  }
  return null;
}

// Pluginクラスファイルを探す（今回はModule探しに変更したため未使用だが念のため）
function findPluginFile(dirPath) {
  const files = fs.readdirSync(dirPath);
  return files.find(f => f.endsWith('.plugin.ts'));
}

function generateRegistryFile(outputPath, plugins, isProduction) {
  const imports = plugins.map(p => 
    `import { ${p.className} } from './${p.dirName}/${p.fileName}';`
  ).join('\n');

  const list = plugins.map(p => p.className).join(',\n  ');

  const content = `// This file is generated by scripts/generate-plugin-registry.js
// Do not edit manually.

${imports}

export const pluginModules = [
  ${list}
];

export const isProduction = ${isProduction};
`;

  fs.writeFileSync(outputPath, content);
  console.log(`Generated: ${outputPath} (${plugins.length} plugins, isProduction: ${isProduction})`);
}

main();
